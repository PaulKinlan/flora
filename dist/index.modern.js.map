{"version":3,"file":"index.modern.js","sources":["../lib/index.js"],"sourcesContent":["const encoder = new TextEncoder();\n\nconst pipeInto = async (from, controller) => {\n  const reader = from.getReader();\n  \n  return reader.read().then(function process(result) {\n    if (result.done) {\n      return;\n    }\n    const value = result.value;\n    const isTypedArray = (value instanceof Int8Array\n      || value instanceof Int16Array\n      || value instanceof Int32Array\n      || value instanceof Uint8Array\n      || value instanceof Uint8ClampedArray\n      || value instanceof Uint16Array\n      || value instanceof Uint32Array\n      || value instanceof Float32Array\n      || value instanceof Float64Array)\n    if((isTypedArray === false && !!result.value) || (isTypedArray && value.length > 0)) {\n      controller.enqueue(result.value);\n    }\n    return reader.read().then(process);\n  });\n};\n\nconst enqueueItem = async (val, controller) => {\n  if (val instanceof globalThis.ReadableStream) {\n    await pipeInto(val, controller);\n  } \n  else if (val instanceof Promise) {\n    let newVal;\n    newVal = await val;\n\n    if (newVal instanceof globalThis.ReadableStream) {\n      await pipeInto(newVal, controller);\n    } else {\n      await enqueueItem(newVal, controller);\n    }\n  }\n  else {\n    if (Array.isArray(val)) {\n      for (let item of val) {\n        await enqueueItem(item, controller)\n      }\n    }\n    else if (!!val) {\n      controller.enqueue(encoder.encode(val));\n    }\n  }\n}\n\nexport default async (strings, ...values) => {\n  if (\"ReadableStream\" in globalThis === false) {\n    // For node not supporting streams properly..... This should tree-shake away\n    let { ReadableStream } = await import(\"web-streams-polyfill\");\n  }\n  return new globalThis.ReadableStream({\n    start(controller) {\n      async function push() {\n        let i = 0;\n        while (i < values.length) {\n          let html = strings[i];\n          controller.enqueue(encoder.encode(html));\n          await enqueueItem(values[i], controller);\n\n          i++;\n        }\n        controller.enqueue(encoder.encode(strings[i]));\n        controller.close();\n      }\n\n      push();\n    }\n  });\n};"],"names":["encoder","TextEncoder","pipeInto","async","from","controller","reader","getReader","read","then","process","result","done","value","isTypedArray","Int8Array","Int16Array","Int32Array","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","Float32Array","Float64Array","length","enqueue","enqueueItem","val","globalThis","ReadableStream","Promise","newVal","Array","isArray","item","encode","strings","values","start","i","close","push"],"mappings":"AAAA,MAAMA,EAAU,IAAIC,YAEdC,EAAWC,MAAOC,EAAMC,KAC5B,MAAMC,EAASF,EAAKG,YAEpB,OAAOD,EAAOE,OAAOC,KAAK,SAASC,EAAQC,GACzC,GAAIA,EAAOC,KACT,OAEF,MAAMC,EAAQF,EAAOE,MACfC,EAAgBD,aAAiBE,WAClCF,aAAiBG,YACjBH,aAAiBI,YACjBJ,aAAiBK,YACjBL,aAAiBM,mBACjBN,aAAiBO,aACjBP,aAAiBQ,aACjBR,aAAiBS,cACjBT,aAAiBU,aAItB,QAHqB,IAAjBT,GAA4BH,EAAOE,OAAWC,GAAgBD,EAAMW,OAAS,IAC/EnB,EAAWoB,QAAQd,EAAOE,OAErBP,EAAOE,OAAOC,KAAKC,MAIxBgB,EAAcvB,MAAOwB,EAAKtB,KAC9B,GAAIsB,aAAeC,WAAWC,qBACtB3B,EAASyB,EAAKtB,WAEbsB,aAAeG,QAAS,CAC/B,IAAIC,EACJA,QAAeJ,EAEXI,aAAkBH,WAAWC,qBACzB3B,EAAS6B,EAAQ1B,SAEjBqB,EAAYK,EAAQ1B,QAI5B,GAAI2B,MAAMC,QAAQN,GAChB,IAAK,IAAIO,KAAQP,QACTD,EAAYQ,EAAM7B,QAGjBsB,GACTtB,EAAWoB,QAAQzB,EAAQmC,OAAOR,0BAKlBS,KAAYC,KAC5B,mBAAoBT,YAAe,gBAEC,4BAE7BA,WAAWC,eAAe,CACnCS,MAAMjC,IACJF,iBACE,IAAIoC,EAAI,EACR,KAAOA,EAAIF,EAAOb,QAEhBnB,EAAWoB,QAAQzB,EAAQmC,OADhBC,EAAQG,WAEbb,EAAYW,EAAOE,GAAIlC,GAE7BkC,IAEFlC,EAAWoB,QAAQzB,EAAQmC,OAAOC,EAAQG,KAC1ClC,EAAWmC,QAGbC"}